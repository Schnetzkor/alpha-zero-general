1.Phasen: Es gibt 4 Phasen in einem Muehle-Spiel:
    I: Auslegen der Steine
    II: Einen eigenen Stein eliminieren: Extra Zug fuer den Spieler mit anderen Regeln
    III: Einen Stein bewegen (muessen)
    IV: Einen eigenen Stein flexibel bewegen (muessen)

Implementierung des Spielfeldes:
---------
|A--B--C|
|-D-E-F-|
|--GHI--|
|JKL-MNO|
|--PQR--|
|-S-T-U-|
|V--W--Y|
---------

Übergebe den Vektor als:
{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,Y}

Bessere Idee:
8x3 oder 3x8 Matrix:


=>

Darstellung als eine art Reuse. Wobei ecken durch ungerade und Kannten durch gerade Indizes dargestellt
werden.

<- 0,0 - 0,1 - 0,2 - 0,3 - 0,4 - 0,5 - 0,6 - 0,7 ->
    |           |           |           |
<- 1,0 - 1,1 - 1,2 - 1,3 - 1,4 - 1,5 - 1,6 - 1,7 ->
    |           |           |           |
<- 2,0 - 2,1 - 2,2 - 2,3 - 2,4 - 2,5 - 2,6 - 2,7 ->

Daraus ergibt sich folgendes regelwerk:
Bewegung zwischen den ebenen sind möglich wenn der zweite Index gerade ist.
eine Mühle enthält drei aufeinander folgende Felder von denen entweder einer der letzten indizes oder alle drei der
letzten indizes gerade sind.
=>
Klassische Darstellung

2,7 ------------- 2,0 ------------- 2,1
 |                 |                 |
 |    1,7 ------- 1,0 ------- 1,1    |
 |     |           |           |     |
 |     |    0,7 - 0,0 - 0,1    |     |
 |     |     |           |     |     |
2,6 - 1,6 - 0,6         0,2 - 1,2 - 2,2
 |     |     |           |     |     |
 |     |    0,5 - 0,4 - 0,3    |     |
 |     |           |           |     |
 |    1,5 ------- 1,4 ------- 1,3    |
 |                 |                 |
2,5 ------------- 2,4 ------------- 2,5
Legale Zuege Phase 1:
Iteriere ueber den Vektor, unbelegte Stellen = legal

Legale Zuege Phase 2, Eliminiation:
Iteriere ueber den Vektor, vom Gegner belegte Stellen die nicht in einer Muehle sind = legaler Zug

Legale Zuege Phase 3: Iteriere ueber Vektor, bei eigenen Steinen, wenn eine Nachbarposition frei ist = legaler Zug
Speichere die Nachbarn ab:
A: B,j
B: A,C, E
usw.

Legale Zuege Phase 4: Alle freien Felder sind legale Zuege, Differenzierung der Herkunft? Schachschreibweise ist d4xe5 bzw.

Checken ob eine Muehle vorhanden ist:
Speichere mögliche Kombinationen für jede Position ab:
A: ABC, AJV
B: ABC, BEH
usw.

Wenn Stein auf Position gezogen wird, iteriere ueber die Kombinationen (optimal: minus die, aus der der Stein kommt, dort kann keine Muehle sein)


-------------------------------------------------------------------------------
GUI:
1. Anforderungen: Was soll die GUI koennen?
    I.Das Brett darstellen, also leere Felder und die Verbindungen.
        Leere Felder = Grau, Verbindungen= Schwarz, Hintergrund = Weiss?, Simon fragen
        Wir brauchen Felder, die mit 4 unterschiedlichen Farben gefuellt sein koennen: Leer, Moeglicher Zug, Spielstein
        Dazu Verbindungen zwischen den Feldern, die Schwarz sein sollen.
        Verbindungen erstellen: uebernehmen aus den schleifen fuer legale Zuege.
    II. Steine eindeutig darstellen
         Spieler1=Blau, Spieler2=Gelb
    III. Optional: Legale Zuege darstellen
        Idee: Legale Zuege sind Steine mit Farbe= Gruen
    IV. Updatezeitpunkte: Zug ist committed, Spielerwechsel erfolgt und möglichte Züge vorhanden
        Menschlicher Spieler: Lese den Mausklick auf den gruenen Stein (=möglicher Zug) aus und comitted den Zug.

        Punktdefinitionen zum Zeichnen:
        Kreis = Groeße zu definieren
        Balken =  Zentriert auf Mittelpunkt d. entsprechenden Kreise
        Balken_lang =3*Durchmesser_Kreis
        Balken_mittel = 2*Durchmesser_Kreis
        Balken_klein = 1*Durchmesser_Kreis
            Farbe:
                Hintergrund = Weiß
                Balken = Schwarz
                Leeres Feld = Grau
                Spieler1 = Blau
                Spieler2= Gelb
                Legale Zuege aktiver Spieler = Gruen

        Links oben Kreis zeichnen, dann einen Balken der zentriert ist auf Höhe des Mittelpunktes des Kreises rechts & unten
        Mittleren oberen Kreis zeichnen, dann Balken rechts & unten
        Rechten oberen Kreis zeichnen, dann Balken nach unten
        Kreis rechte Mitte, Balken nach links & unten
        Kreis rechts unten, Balken nach links
        Kreis untere Mitte, Balken nach oben und links
        Kreis unten links, Balken nach oben
        Kreis linke Mitte, Balken nach rechts
        Kreis links mittlere Ebene, Balken nach unten, oben, rechts,
        weiter rotieren in Spinnennetzmuster, wie in Ebene 1

2. Codefragmente als Start aus spider 4gewinnt:
    Aufrufe am Ende des Codes:
        SQUARESIZE = 100

        width = COLUMN_COUNT * SQUARESIZE  / Wir brauchen Platz fuer die Felder und Verbindungen, zur Erstellung der GUI: Balkengröße: 4,8. 16? Wenn Stein =2,1? Wie Reuse umrechnen in Koordinaten fuer GUI? Oder einfach ignorieren und spiegeln, weil das Brett sowieso symmetirsch ist?
        height = ROW_COUNT * SQUARESIZE     / Dann wäre Column_count = 2*Steinanzahl+16*2 = Row_count, Squaresize = "Zoom"

        size = (width, height)

        RADIUS = int(SQUARESIZE / 2 - 5)  / Mir ist nicht klar wozu das hier ist?

        screen = pygame.display.set_mode(size)
        draw_board(board)
        pygame.display.update()

        myfont = pygame.font.SysFont("monospace", 75) / Standard hier

        col = -1
        row = -1
        valid_locations = initial_valid_locations(board) / hier valid_moves

    draw_board:
        def draw_board(board_):
             for c in range(COLUMN_COUNT):
                  for r in range(ROW_COUNT):
                      pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r *                   / Hier basisfeld:  .draw.rect () fuer Verbindungen der Balken, circle fuer Steine, erst ein rectangle als Hintergrund = weiss, Verbindungen = Schwarz,
                                            SQUARESIZE, SQUARESIZE, SQUARESIZE))            / resizing ist hier einfach nur mit squaresize, das sollte auch möglich sein sobald wir uns auf Balkengröße usw. geeinigt haben.
                      pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2),
                                               int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)

             for c in range(COLUMN_COUNT):                                                          / Hier die Spieler, kann uebernommen werden, Farbe auswählbar.
                for r in range(ROW_COUNT):
                    if board_[r][c] == 1:
                    pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2),
                                                 height - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)
            elif board_[r][c] == 2:
                pygame.draw.circle(screen, YELLOW, (int(
                    c * SQUARESIZE + SQUARESIZE / 2), height - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)
    pygame.display.update

    Umgesetzter Code:

    draw_board:
        def draw_board
